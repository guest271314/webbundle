{
  "version": 3,
  "sources": ["src/index.ts", "shared/utils.ts", "shared/iwa-headers.ts", "shared/utils.ts", "src/index.ts"],
  "sourcesContent": [
    "/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BundleBuilder } from \"wbn\";\nimport {\n  addAsset,\n  addFilesRecursively,\n  getSignedWebBundle,\n} from \"../shared/utils\";\nimport {\n  // getValidatedOptionsWithDefaults,\n  PluginOptions,\n} from \"../shared/types\";\n\nconst consoleLogColor = { green: \"\\x1b[32m\", reset: \"\\x1b[0m\" };\nfunction infoLogger(text: string): void {\n  console.log(`${consoleLogColor.green}${text}${consoleLogColor.reset}\\n`);\n}\n\n// TODO(sonkkeli): Probably this depends on the Rollup version. Figure out how\n// this should be refactored.\n// https://rollupjs.org/plugin-development/#build-hooks\n// type EnforcedPlugin = Plugin & { enforce: \"post\" | \"pre\" | null };\nexport default async function bundleIsolatedWebApp(\n  opts: PluginOptions,\n): Promise<void> /*: EnforcedPlugin */ {\n  // const opts = await getValidatedOptionsWithDefaults(rawOpts);\n  const builder = new BundleBuilder(opts.formatVersion);\n  if (\"primaryURL\" in opts && opts.primaryURL) {\n    builder.setPrimaryURL(opts.primaryURL);\n  }\n\n  if (opts.static) {\n    addFilesRecursively(\n      builder,\n      opts.static.baseURL ?? opts.baseURL,\n      opts.static.dir,\n      opts,\n    );\n  }\n\n  let webBundle = builder.createBundle();\n  if (\"integrityBlockSign\" in opts) {\n    webBundle = await getSignedWebBundle(webBundle, opts, infoLogger);\n  }\n  return {\n    fileName: opts.output,\n    source: webBundle,\n  };\n}\n",
  "/*!\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport mime from \"mime\";\nimport { BundleBuilder, combineHeadersForUrl } from \"wbn\";\nimport { IntegrityBlockSigner, WebBundleId } from \"wbn-sign-webcrypto\";\nimport { checkAndAddIwaHeaders } from \"./iwa-headers\";\nimport { ValidIbSignPluginOptions, ValidPluginOptions } from \"./types\";\n\n// If the file name is 'index.html', create an entry for both baseURL/dir/ and\n// baseURL/dir/index.html which redirects to the aforementioned. Otherwise just\n// for the asset itself. This matches the behavior of gen-bundle.\nexport function addAsset(\n  builder: BundleBuilder,\n  baseURL: string,\n  relativeAssetPath: string, // Asset's path relative to app's base dir. E.g. sub-dir/helloworld.js\n  assetContentBuffer: Uint8Array | string,\n  pluginOptions: ValidPluginOptions,\n) {\n  const parsedAssetPath = path.parse(relativeAssetPath);\n  const isIndexHtmlFile = parsedAssetPath.base === \"index.html\";\n\n  // For object type, the IWA headers have already been check in constructor.\n  const shouldCheckIwaHeaders =\n    typeof pluginOptions.headerOverride === \"function\" &&\n    \"integrityBlockSign\" in pluginOptions &&\n    pluginOptions.integrityBlockSign.isIwa;\n\n  if (isIndexHtmlFile) {\n    const combinedIndexHeaders = combineHeadersForUrl(\n      { Location: \"./\" },\n      pluginOptions.headerOverride,\n      baseURL + relativeAssetPath,\n    );\n    if (shouldCheckIwaHeaders) checkAndAddIwaHeaders(combinedIndexHeaders);\n\n    builder.addExchange(\n      baseURL + relativeAssetPath,\n      301,\n      combinedIndexHeaders,\n      \"\", // Empty content.\n    );\n  }\n\n  const baseURLWithAssetPath = baseURL +\n    (isIndexHtmlFile ? parsedAssetPath.dir : relativeAssetPath);\n  const combinedHeaders = combineHeadersForUrl(\n    {\n      \"Content-Type\": mime.getType(relativeAssetPath) ||\n        \"application/octet-stream\",\n    },\n    pluginOptions.headerOverride,\n    baseURLWithAssetPath,\n  );\n  if (shouldCheckIwaHeaders) checkAndAddIwaHeaders(combinedHeaders);\n\n  builder.addExchange(\n    baseURLWithAssetPath,\n    200,\n    combinedHeaders,\n    assetContentBuffer,\n  );\n}\n\nexport function addFilesRecursively(\n  builder: BundleBuilder,\n  baseURL: string,\n  dir: string,\n  pluginOptions: ValidPluginOptions,\n  recPath = \"\",\n) {\n  const files = fs.readdirSync(dir);\n  files.sort(); // Sort entries for reproducibility.\n\n  for (const fileName of files) {\n    const filePath = path.join(dir, fileName);\n\n    if (fs.statSync(filePath).isDirectory()) {\n      addFilesRecursively(\n        builder,\n        baseURL,\n        filePath,\n        pluginOptions,\n        recPath + fileName + \"/\",\n      );\n    } else {\n      const fileContent = fs.readFileSync(filePath);\n      // `fileName` contains the directory as this is done recursively for every\n      // directory so it gets added to the baseURL.\n      addAsset(\n        builder,\n        baseURL,\n        recPath + fileName,\n        fileContent,\n        pluginOptions,\n      );\n    }\n  }\n}\n\nexport async function getSignedWebBundle(\n  webBundle: Uint8Array,\n  opts: ValidIbSignPluginOptions,\n  infoLogger: (str: string) => void,\n): Promise<Uint8Array> {\n  const { signedWebBundle } = await new IntegrityBlockSigner(\n    webBundle,\n    opts.integrityBlockSign.strategy,\n  ).sign();\n\n  const origin = await new WebBundleId(\n    await opts.integrityBlockSign.strategy.getPublicKey(),\n  ).serializeWithIsolatedWebAppOrigin();\n\n  infoLogger(origin);\n  return signedWebBundle;\n}\n",
  "/*!\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Headers } from \"./types\";\n\nexport const coep: Headers = Object.freeze({\n  \"cross-origin-embedder-policy\": \"require-corp\",\n});\nexport const coop: Headers = Object.freeze({\n  \"cross-origin-opener-policy\": \"same-origin\",\n});\nexport const corp: Headers = Object.freeze({\n  \"cross-origin-resource-policy\": \"same-origin\",\n});\n\nexport const CSP_HEADER_NAME = \"content-security-policy\";\nexport const csp: Headers = Object.freeze({\n  [CSP_HEADER_NAME]:\n    \"base-uri 'none'; default-src 'self'; object-src 'none'; frame-src 'self' https: blob: data:; connect-src 'self' https: wss:; script-src 'self' 'wasm-unsafe-eval'; img-src 'self' https: blob: data:; media-src 'self' https: blob: data:; font-src 'self' blob: data:; style-src 'self' 'unsafe-inline'; require-trusted-types-for 'script'; frame-ancestors 'self';\",\n});\n\n// These headers must have these exact values for Isolated Web Apps, whereas the\n// CSP header can also be more strict.\nconst invariableIwaHeaders: Headers = Object.freeze({\n  ...coep,\n  ...coop,\n  ...corp,\n});\n\nexport const iwaHeaderDefaults: Headers = Object.freeze({\n  ...csp,\n  ...invariableIwaHeaders,\n});\n\nfunction headerNamesToLowerCase(headers: Headers): Headers {\n  const lowerCaseHeaders: Headers = {};\n  for (const [headerName, headerValue] of Object.entries(headers)) {\n    lowerCaseHeaders[headerName.toLowerCase()] = headerValue;\n  }\n  return lowerCaseHeaders;\n}\n\nconst ifNotIwaMsg =\n  \"If you are bundling a non-IWA, set `integrityBlockSign: { isIwa: false }` in the plugin's configuration.\";\n\n// Checks if the IWA headers are strict enough or adds in case missing.\nexport function checkAndAddIwaHeaders(headers: Headers) {\n  const lowerCaseHeaders = headerNamesToLowerCase(headers);\n\n  // Add missing IWA headers.\n  for (\n    const [iwaHeaderName, iwaHeaderValue] of Object.entries(\n      iwaHeaderDefaults,\n    )\n  ) {\n    if (!lowerCaseHeaders[iwaHeaderName]) {\n      console.log(\n        `For Isolated Web Apps, ${iwaHeaderName} header was automatically set to ${iwaHeaderValue}. ${ifNotIwaMsg}`,\n      );\n      headers[iwaHeaderName] = iwaHeaderValue;\n    }\n  }\n\n  // Check strictness of IWA headers (apart from special case `Content-Security-Policy`).\n  for (\n    const [iwaHeaderName, iwaHeaderValue] of Object.entries(\n      invariableIwaHeaders,\n    )\n  ) {\n    if (\n      lowerCaseHeaders[iwaHeaderName] &&\n      lowerCaseHeaders[iwaHeaderName].toLowerCase() !== iwaHeaderValue\n    ) {\n      throw new Error(\n        `For Isolated Web Apps ${iwaHeaderName} should be ${iwaHeaderValue}. Now it is ${\n          headers[iwaHeaderName]\n        }. ${ifNotIwaMsg}`,\n      );\n    }\n  }\n\n  // TODO: Parse and check strictness of `Content-Security-Policy`.\n}\n",
  "/*!\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport mime from \"mime\";\nimport { BundleBuilder, combineHeadersForUrl } from \"wbn\";\nimport { IntegrityBlockSigner, WebBundleId } from \"wbn-sign-webcrypto\";\nimport { checkAndAddIwaHeaders } from \"./iwa-headers\";\nimport { ValidIbSignPluginOptions, ValidPluginOptions } from \"./types\";\n\n// If the file name is 'index.html', create an entry for both baseURL/dir/ and\n// baseURL/dir/index.html which redirects to the aforementioned. Otherwise just\n// for the asset itself. This matches the behavior of gen-bundle.\nexport function addAsset(\n  builder: BundleBuilder,\n  baseURL: string,\n  relativeAssetPath: string, // Asset's path relative to app's base dir. E.g. sub-dir/helloworld.js\n  assetContentBuffer: Uint8Array | string,\n  pluginOptions: ValidPluginOptions,\n) {\n  const parsedAssetPath = path.parse(relativeAssetPath);\n  const isIndexHtmlFile = parsedAssetPath.base === \"index.html\";\n\n  // For object type, the IWA headers have already been check in constructor.\n  const shouldCheckIwaHeaders =\n    typeof pluginOptions.headerOverride === \"function\" &&\n    \"integrityBlockSign\" in pluginOptions &&\n    pluginOptions.integrityBlockSign.isIwa;\n\n  if (isIndexHtmlFile) {\n    const combinedIndexHeaders = combineHeadersForUrl(\n      { Location: \"./\" },\n      pluginOptions.headerOverride,\n      baseURL + relativeAssetPath,\n    );\n    if (shouldCheckIwaHeaders) checkAndAddIwaHeaders(combinedIndexHeaders);\n\n    builder.addExchange(\n      baseURL + relativeAssetPath,\n      301,\n      combinedIndexHeaders,\n      \"\", // Empty content.\n    );\n  }\n\n  const baseURLWithAssetPath = baseURL +\n    (isIndexHtmlFile ? parsedAssetPath.dir : relativeAssetPath);\n  const combinedHeaders = combineHeadersForUrl(\n    {\n      \"Content-Type\": mime.getType(relativeAssetPath) ||\n        \"application/octet-stream\",\n    },\n    pluginOptions.headerOverride,\n    baseURLWithAssetPath,\n  );\n  if (shouldCheckIwaHeaders) checkAndAddIwaHeaders(combinedHeaders);\n\n  builder.addExchange(\n    baseURLWithAssetPath,\n    200,\n    combinedHeaders,\n    assetContentBuffer,\n  );\n}\n\nexport function addFilesRecursively(\n  builder: BundleBuilder,\n  baseURL: string,\n  dir: string,\n  pluginOptions: ValidPluginOptions,\n  recPath = \"\",\n) {\n  const files = fs.readdirSync(dir);\n  files.sort(); // Sort entries for reproducibility.\n\n  for (const fileName of files) {\n    const filePath = path.join(dir, fileName);\n\n    if (fs.statSync(filePath).isDirectory()) {\n      addFilesRecursively(\n        builder,\n        baseURL,\n        filePath,\n        pluginOptions,\n        recPath + fileName + \"/\",\n      );\n    } else {\n      const fileContent = fs.readFileSync(filePath);\n      // `fileName` contains the directory as this is done recursively for every\n      // directory so it gets added to the baseURL.\n      addAsset(\n        builder,\n        baseURL,\n        recPath + fileName,\n        fileContent,\n        pluginOptions,\n      );\n    }\n  }\n}\n\nexport async function getSignedWebBundle(\n  webBundle: Uint8Array,\n  opts: ValidIbSignPluginOptions,\n  infoLogger: (str: string) => void,\n): Promise<Uint8Array> {\n  const { signedWebBundle } = await new IntegrityBlockSigner(\n    webBundle,\n    opts.integrityBlockSign.strategy,\n  ).sign();\n\n  const origin = await new WebBundleId(\n    await opts.integrityBlockSign.strategy.getPublicKey(),\n  ).serializeWithIsolatedWebAppOrigin();\n\n  infoLogger(origin);\n  return signedWebBundle;\n}\n",
  "/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BundleBuilder } from \"wbn\";\nimport {\n  addAsset,\n  addFilesRecursively,\n  getSignedWebBundle,\n} from \"../shared/utils\";\nimport {\n  // getValidatedOptionsWithDefaults,\n  PluginOptions,\n} from \"../shared/types\";\n\nconst consoleLogColor = { green: \"\\x1b[32m\", reset: \"\\x1b[0m\" };\nfunction infoLogger(text: string): void {\n  console.log(`${consoleLogColor.green}${text}${consoleLogColor.reset}\\n`);\n}\n\n// TODO(sonkkeli): Probably this depends on the Rollup version. Figure out how\n// this should be refactored.\n// https://rollupjs.org/plugin-development/#build-hooks\n// type EnforcedPlugin = Plugin & { enforce: \"post\" | \"pre\" | null };\nexport default async function bundleIsolatedWebApp(\n  opts: PluginOptions,\n): Promise<void> /*: EnforcedPlugin */ {\n  // const opts = await getValidatedOptionsWithDefaults(rawOpts);\n  const builder = new BundleBuilder(opts.formatVersion);\n  if (\"primaryURL\" in opts && opts.primaryURL) {\n    builder.setPrimaryURL(opts.primaryURL);\n  }\n\n  if (opts.static) {\n    addFilesRecursively(\n      builder,\n      opts.static.baseURL ?? opts.baseURL,\n      opts.static.dir,\n      opts,\n    );\n  }\n\n  let webBundle = builder.createBundle();\n  if (\"integrityBlockSign\" in opts) {\n    webBundle = await getSignedWebBundle(webBundle, opts, infoLogger);\n  }\n  return {\n    fileName: opts.output,\n    source: webBundle,\n  };\n}\n"
  ],
  "mappings": ";;AA/////fAgBA,yBAAS;;;AC/gggggBTgBA;AACA;AACA;AACA;AACA;;;ACnhggggBA+CA,IAAS,iCAAsB,CAAC,SAA2B;AACzD,QAAM,mBAA4B,CAAC;AACnC,cAAY,YAAY,gBAAgB,OAAO,QAAQ,OAAO,GAAG;AAC/D,qBAAiB,WAAW,YAAY,KAAK;AAAA,EAC/C;AACA,SAAO;AAAA;AAOF,SAAS,qBAAqB,CAAC,SAAkB;AACtD,QAAM,mBAAmB,uBAAuB,OAAO;AAGvD,cACS,eAAe,mBAAmB,OAAO,QAC9C,iBACF,GACA;AACA,SAAK,iBAAiB,gBAAgB;AACpC,cAAQ,IACN,0BAA0B,iDAAiD,mBAAmB,aAChG;AACA,cAAQ,iBAAiB;AAAA,IAC3B;AAAA,EACF;AAGA,cACS,eAAe,mBAAmB,OAAO,QAC9C,oBACF,GACA;AACA,QACE,iBAAiB,kBACjB,iBAAiB,eAAe,YAAY,MAAM,gBAClD;AACA,YAAM,IAAI,MACR,yBAAyB,2BAA2B,6BAClD,QAAQ,mBACL,aACP;AAAA,IACF;AAAA,EACF;AAAA;AA5EF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEO,IAAM,OAAgB,OAAO,OAAO;AAAA,EACzC,gCAAgC;AAClC,CAAC;AACM,IAAM,OAAgB,OAAO,OAAO;AAAA,EACzC,8BAA8B;AAChC,CAAC;AACM,IAAM,OAAgB,OAAO,OAAO;AAAA,EACzC,gCAAgC;AAClC,CAAC;AAEM,IAAM,kBAAkB;AACxB,IAAM,MAAe,OAAO,OAAO;AAAA,GACvC,kBACC;AACJ,CAAC;AAID,IAAM,uBAAgC,OAAO,OAAO;AAAA,KAC/C;AAAA,KACA;AAAA,KACA;AACL,CAAC;AAEM,IAAM,oBAA6B,OAAO,OAAO;AAAA,KACnD;AAAA,KACA;AACL,CAAC;AAUD,IAAM,cACJ;",
  "debugId": "C89D2538F4A0883964756e2164756e21",
  "names": []
}